## 1. init() 函数是什么时候执行的？

<details open="" style="box-sizing: border-box; margin-top: 10px; margin-bottom: 10px; padding: 5px 10px; border-width: 1px; border-style: solid; border-color: rgb(227, 227, 227) rgb(236, 236, 236) rgb(224, 224, 224) rgb(227, 227, 227); border-image: initial; background-color: rgb(240, 248, 255); box-shadow: rgba(0, 0, 0, 0.07) 1px 2px 1px;"><summary style="box-sizing: border-box; cursor: pointer; font-weight: bold; user-select: none;">答案</summary><div style="box-sizing: border-box;"><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;"><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">init()</code><span>&nbsp;</span>函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。</p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">init()</code><span>&nbsp;</span>函数。同一个包，甚至是同一个源文件可以有多个<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">init()</code><span>&nbsp;</span>函数。<code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">init()</code><span>&nbsp;</span>函数没有入参和返回值，不能被其他函数调用，同一个包内多个<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">init()</code><span>&nbsp;</span>函数的执行顺序不作保证。</p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">一句话总结： import –&gt; const –&gt; var –&gt;<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">init()</code><span>&nbsp;</span>–&gt;<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">main()</code></p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">示例：</p><figure class="highlight go" style="box-sizing: border-box; margin: 10px 0px 20px; padding: 15px; overflow: auto; font-size: 13px; color: rgb(36, 41, 46); background: rgb(246, 248, 250); line-height: 1.8;"><table style="box-sizing: border-box; border-collapse: collapse; border-spacing: 0px; margin: 0px; display: block; width: auto; overflow: auto; border: none;"><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: transparent; border-top: none;"><td class="code" style="box-sizing: border-box; padding: 0px; text-align: left; border: none !important;"><pre style="box-sizing: border-box; margin: 0px; padding: 1px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; overflow-wrap: normal; overflow: auto; line-height: 1.8; background: rgb(246, 248, 250); border-radius: 3px; font-size: 13px; color: rgb(36, 41, 46); border: none;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">package</span> main</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">import</span> <span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"fmt"</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">init</span><span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span>  {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Println(<span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"init1:"</span>, a)</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">init</span><span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span>  {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Println(<span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"init2:"</span>, a)</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">var</span> a = <span class="number" style="box-sizing: border-box; color: rgb(113, 140, 0);">10</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">const</span> b = <span class="number" style="box-sizing: border-box; color: rgb(113, 140, 0);">100</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">main</span><span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span> {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Println(<span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"main:"</span>, a)</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// 执行结果</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// init1: 10</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// init2: 10</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// main: 10</span></span><br style="box-sizing: border-box;"></pre></td></tr></tbody></table></figure></div></details>

## 2. Go 语言的局部变量分配在栈上还是堆上？

<details open="" style="box-sizing: border-box; margin-top: 10px; margin-bottom: 10px; padding: 5px 10px; border-width: 1px; border-style: solid; border-color: rgb(227, 227, 227) rgb(236, 236, 236) rgb(224, 224, 224) rgb(227, 227, 227); border-image: initial; background-color: rgb(240, 248, 255); box-shadow: rgba(0, 0, 0, 0.07) 1px 2px 1px;"><summary style="box-sizing: border-box; cursor: pointer; font-weight: bold; user-select: none;">答案</summary><div style="box-sizing: border-box;"><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。</p><figure class="highlight go" style="box-sizing: border-box; margin: 10px 0px 20px; padding: 15px; overflow: auto; font-size: 13px; color: rgb(36, 41, 46); background: rgb(246, 248, 250); line-height: 1.8;"><table style="box-sizing: border-box; border-collapse: collapse; border-spacing: 0px; margin: 0px; display: block; width: auto; overflow: auto; border: none;"><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: transparent; border-top: none;"><td class="code" style="box-sizing: border-box; padding: 0px; text-align: left; border: none !important;"><pre style="box-sizing: border-box; margin: 0px; padding: 1px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; overflow-wrap: normal; overflow: auto; line-height: 1.8; background: rgb(246, 248, 250); border-radius: 3px; font-size: 13px; color: rgb(36, 41, 46); border: none;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">foo</span><span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span> *<span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">int</span></span> {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	v := <span class="number" style="box-sizing: border-box; color: rgb(113, 140, 0);">11</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">return</span> &amp;v</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">main</span><span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span> {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	m := foo()</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	<span class="built_in" style="box-sizing: border-box; color: rgb(227, 98, 9);">println</span>(*m) <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// 11</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"></pre></td></tr></tbody></table></figure><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;"><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">foo()</code><span>&nbsp;</span>函数中，如果 v 分配在栈上，foo 函数返回时，<code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">&amp;v</code><span>&nbsp;</span>就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值。</p></div></details>

## 3. 2 个 interface 可以比较吗？

<details open="" style="box-sizing: border-box; margin-top: 10px; margin-bottom: 10px; padding: 5px 10px; border-width: 1px; border-style: solid; border-color: rgb(227, 227, 227) rgb(236, 236, 236) rgb(224, 224, 224) rgb(227, 227, 227); border-image: initial; background-color: rgb(240, 248, 255); box-shadow: rgba(0, 0, 0, 0.07) 1px 2px 1px;"><summary style="box-sizing: border-box; cursor: pointer; font-weight: bold; user-select: none;">答案</summary><div style="box-sizing: border-box;"><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">Go 语言中，interface 的内部实现包含了 2 个字段，类型<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">T</code><span>&nbsp;</span>和 值<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">V</code>，interface 可以使用<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">==</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">!=</code><span>&nbsp;</span>比较。2 个 interface 相等有以下 2 种情况</p><ol style="box-sizing: border-box; margin: 10px 0px; padding: 0px 0px 0px 1.5em;"><li style="box-sizing: border-box; margin: 0px; padding: 0px;">两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">类型 T 相同，且对应的值 V 相等。</li></ol><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">看下面的例子：</p><figure class="highlight go" style="box-sizing: border-box; margin: 10px 0px 20px; padding: 15px; overflow: auto; font-size: 13px; color: rgb(36, 41, 46); background: rgb(246, 248, 250); line-height: 1.8;"><table style="box-sizing: border-box; border-collapse: collapse; border-spacing: 0px; margin: 0px; display: block; width: auto; overflow: auto; border: none;"><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: transparent; border-top: none;"><td class="code" style="box-sizing: border-box; padding: 0px; text-align: left; border: none !important;"><pre style="box-sizing: border-box; margin: 0px; padding: 1px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; overflow-wrap: normal; overflow: auto; line-height: 1.8; background: rgb(246, 248, 250); border-radius: 3px; font-size: 13px; color: rgb(36, 41, 46); border: none;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">type</span> Stu <span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">struct</span> {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	Name <span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">string</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">type</span> StuInt <span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">interface</span>{}</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">main</span><span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span> {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">var</span> stu1, stu2 StuInt = &amp;Stu{<span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"Tom"</span>}, &amp;Stu{<span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"Tom"</span>}</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">var</span> stu3, stu4 StuInt = Stu{<span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"Tom"</span>}, Stu{<span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"Tom"</span>}</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Println(stu1 == stu2) <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// false</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Println(stu3 == stu4) <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// true</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"></pre></td></tr></tbody></table></figure><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;"><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">stu1</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">stu2</code><span>&nbsp;</span>对应的类型是<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">*Stu</code>，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。<br style="box-sizing: border-box;"><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">stu3</code><span>&nbsp;</span>和<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">stu4</code><span>&nbsp;</span>对应的类型是<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">Stu</code>，值是 Stu 结构体，且各字段相等，因此结果为 true。</p></div></details>

## 4. 两个 nil 可能不相等吗？

<details open="" style="box-sizing: border-box; margin-top: 10px; margin-bottom: 10px; padding: 5px 10px; border-width: 1px; border-style: solid; border-color: rgb(227, 227, 227) rgb(236, 236, 236) rgb(224, 224, 224) rgb(227, 227, 227); border-image: initial; background-color: rgb(240, 248, 255); box-shadow: rgba(0, 0, 0, 0.07) 1px 2px 1px;"><summary style="box-sizing: border-box; cursor: pointer; font-weight: bold; user-select: none;">答案</summary><div style="box-sizing: border-box;"><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">可能。</p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">T</code><span>&nbsp;</span>和 值<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">V</code>。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。</p><ul style="box-sizing: border-box; margin: 10px 0px; padding: 0px 0px 0px 1.5em; list-style-type: square;"><li style="box-sizing: border-box; margin: 0px; padding: 0px;">两个接口值比较时，会先比较 T，再比较 V。</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。</li></ul><figure class="highlight go" style="box-sizing: border-box; margin: 10px 0px 20px; padding: 15px; overflow: auto; font-size: 13px; color: rgb(36, 41, 46); background: rgb(246, 248, 250); line-height: 1.8;"><table style="box-sizing: border-box; border-collapse: collapse; border-spacing: 0px; margin: 0px; display: block; width: auto; overflow: auto; border: none;"><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: transparent; border-top: none;"><td class="code" style="box-sizing: border-box; padding: 0px; text-align: left; border: none !important;"><pre style="box-sizing: border-box; margin: 0px; padding: 1px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; overflow-wrap: normal; overflow: auto; line-height: 1.8; background: rgb(246, 248, 250); border-radius: 3px; font-size: 13px; color: rgb(36, 41, 46); border: none;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">main</span><span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span> {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">var</span> p *<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">int</span> = <span class="literal" style="box-sizing: border-box; color: rgb(227, 98, 9);">nil</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">var</span> i <span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">interface</span>{} = p</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Println(i == p) <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// true</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Println(p == <span class="literal" style="box-sizing: border-box; color: rgb(227, 98, 9);">nil</span>) <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// true</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Println(i == <span class="literal" style="box-sizing: border-box; color: rgb(227, 98, 9);">nil</span>) <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// false</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"></pre></td></tr></tbody></table></figure><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为<code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">(T=*int, V=nil)</code>，i 与 p 作比较时，将 p 转换为接口后再比较，因此<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">i == p</code>，p 与 nil 比较，直接比较值，所以<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">p == nil</code>。</p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">但是当 i 与 nil 比较时，会将 nil 转换为接口<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">(T=nil, V=nil)</code>，与i<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">(T=*int, V=nil)</code><span>&nbsp;</span>不相等，因此<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">i != nil</code>。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。</p></div></details>

## 5. 简述 Go 语言GC(垃圾回收)的工作原理

<details open="" style="box-sizing: border-box; margin-top: 10px; margin-bottom: 10px; padding: 5px 10px; border-width: 1px; border-style: solid; border-color: rgb(227, 227, 227) rgb(236, 236, 236) rgb(224, 224, 224) rgb(227, 227, 227); border-image: initial; background-color: rgb(240, 248, 255); box-shadow: rgba(0, 0, 0, 0.07) 1px 2px 1px;"><summary style="box-sizing: border-box; cursor: pointer; font-weight: bold; user-select: none;">答案</summary><div style="box-sizing: border-box;"><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。</p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul style="box-sizing: border-box; margin: 10px 0px; padding: 0px 0px 0px 1.5em; list-style-type: square;"><li style="box-sizing: border-box; margin: 0px; padding: 0px;">标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。</li></ul><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul style="box-sizing: border-box; margin: 10px 0px; padding: 0px 0px 0px 1.5em; list-style-type: square;"><li style="box-sizing: border-box; margin: 0px; padding: 0px;">白色：不确定对象。</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">灰色：存活对象，子对象待处理。</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">黑色：存活对象。</li></ul><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。</p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><figure class="highlight bash" style="box-sizing: border-box; margin: 10px 0px 20px; padding: 15px; overflow: auto; font-size: 13px; color: rgb(36, 41, 46); background: rgb(246, 248, 250); line-height: 1.8;"><table style="box-sizing: border-box; border-collapse: collapse; border-spacing: 0px; margin: 0px; display: block; width: auto; overflow: auto; border: none;"><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: transparent; border-top: none;"><td class="code" style="box-sizing: border-box; padding: 0px; text-align: left; border: none !important;"><pre style="box-sizing: border-box; margin: 0px; padding: 1px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; overflow-wrap: normal; overflow: auto; line-height: 1.8; background: rgb(246, 248, 250); border-radius: 3px; font-size: 13px; color: rgb(36, 41, 46); border: none;"><span class="line" style="box-sizing: border-box; height: 20px;">A (黑) -&gt; B (灰) -&gt; C (白) -&gt; D (白)</span><br style="box-sizing: border-box;"></pre></td></tr></tbody></table></figure><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><figure class="highlight bash" style="box-sizing: border-box; margin: 10px 0px 20px; padding: 15px; overflow: auto; font-size: 13px; color: rgb(36, 41, 46); background: rgb(246, 248, 250); line-height: 1.8;"><table style="box-sizing: border-box; border-collapse: collapse; border-spacing: 0px; margin: 0px; display: block; width: auto; overflow: auto; border: none;"><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: transparent; border-top: none;"><td class="code" style="box-sizing: border-box; padding: 0px; text-align: left; border: none !important;"><pre style="box-sizing: border-box; margin: 0px; padding: 1px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; overflow-wrap: normal; overflow: auto; line-height: 1.8; background: rgb(246, 248, 250); border-radius: 3px; font-size: 13px; color: rgb(36, 41, 46); border: none;"><span class="line" style="box-sizing: border-box; height: 20px;">A (黑) -&gt; B (灰) -&gt; C (白) </span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">  ↓</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"> D (白)</span><br style="box-sizing: border-box;"></pre></td></tr></tbody></table></figure><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">一次完整的 GC 分为四个阶段：</p><ul style="box-sizing: border-box; margin: 10px 0px; padding: 0px 0px 0px 1.5em; list-style-type: square;"><li style="box-sizing: border-box; margin: 0px; padding: 0px;">1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">2）使用三色标记法标记（Marking, 并发）</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">3）标记结束(Mark Termination，需 STW)，关闭写屏障。</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">4）清理(Sweeping, 并发)</li></ul><ul style="box-sizing: border-box; margin: 10px 0px; padding: 0px 0px 0px 1.5em; list-style-type: square;"><li style="box-sizing: border-box; margin: 0px; padding: 0px;">参考<span>&nbsp;</span><a target="_blank" rel="noopener" href="https://www.fullstack.cafe/golang" style="box-sizing: border-box; text-decoration: none; color: rgb(51, 122, 183); background-color: transparent;">fullstack</a></li></ul></div></details>

## 6. 函数返回局部变量的指针是否安全？

<details open="" style="box-sizing: border-box; margin-top: 10px; margin-bottom: 10px; padding: 5px 10px; border-width: 1px; border-style: solid; border-color: rgb(227, 227, 227) rgb(236, 236, 236) rgb(224, 224, 224) rgb(227, 227, 227); border-image: initial; background-color: rgb(240, 248, 255); box-shadow: rgba(0, 0, 0, 0.07) 1px 2px 1px;"><summary style="box-sizing: border-box; cursor: pointer; font-weight: bold; user-select: none;">答案</summary><div style="box-sizing: border-box;"><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。</p></div></details>

## 7. 非接口非接口的任意类型 T() 都能够调用 `*T` 的方法吗？反过来呢？

<details open="" style="box-sizing: border-box; margin-top: 10px; margin-bottom: 10px; padding: 5px 10px; border-width: 1px; border-style: solid; border-color: rgb(227, 227, 227) rgb(236, 236, 236) rgb(224, 224, 224) rgb(227, 227, 227); border-image: initial; background-color: rgb(240, 248, 255); box-shadow: rgba(0, 0, 0, 0.07) 1px 2px 1px;"><summary style="box-sizing: border-box; cursor: pointer; font-weight: bold; user-select: none;">答案</summary><div style="box-sizing: border-box;"><ul style="box-sizing: border-box; margin: 10px 0px; padding: 0px 0px 0px 1.5em; list-style-type: square;"><li style="box-sizing: border-box; margin: 0px; padding: 0px;">一个T类型的值可以调用为<code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">*T</code>类型声明的方法，但是仅当此T的值是可寻址(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型<code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">*T</code>声明的方法。</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">反过来，一个<code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">*T</code>类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，编译器都会为类型<code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">*T</code>自动隐式声明一个同名和同签名的方法。</li></ul><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">哪些值是不可寻址的呢？</p><ul style="box-sizing: border-box; margin: 10px 0px; padding: 0px 0px 0px 1.5em; list-style-type: square;"><li style="box-sizing: border-box; margin: 0px; padding: 0px;">字符串中的字节；</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）；</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">常量；</li><li style="box-sizing: border-box; margin: 0px; padding: 0px;">包级别的函数等。</li></ul><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">举一个例子，定义类型 T，并为类型<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">*T</code><span>&nbsp;</span>声明一个方法<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">hello()</code>，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。</p><figure class="highlight go" style="box-sizing: border-box; margin: 10px 0px 20px; padding: 15px; overflow: auto; font-size: 13px; color: rgb(36, 41, 46); background: rgb(246, 248, 250); line-height: 1.8;"><table style="box-sizing: border-box; border-collapse: collapse; border-spacing: 0px; margin: 0px; display: block; width: auto; overflow: auto; border: none;"><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: transparent; border-top: none;"><td class="code" style="box-sizing: border-box; padding: 0px; text-align: left; border: none !important;"><pre style="box-sizing: border-box; margin: 0px; padding: 1px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; overflow-wrap: normal; overflow: auto; line-height: 1.8; background: rgb(246, 248, 250); border-radius: 3px; font-size: 13px; color: rgb(36, 41, 46); border: none;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">type</span> T <span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">string</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">(t *T)</span> <span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">hello</span><span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span> {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Println(<span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"hello"</span>)</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">main</span><span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span> {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">var</span> t1 T = <span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"ABC"</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	t1.hello() <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// hello</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">const</span> t2 T = <span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"ABC"</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	t2.hello() <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// error: cannot call pointer method on t</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"></pre></td></tr></tbody></table></figure></div></details>

------

#### 来源[Go 语言笔试面试题(实现原理) | 极客面试 | 极客兔兔 (geektutu.com)](https://geektutu.com/post/qa-golang-2.html)

